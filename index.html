<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Troll Image — Demo</title>
    <style>
      :root {
        --size: 320px;
        --gap: 24px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        min-height: 100vh;
        margin: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(
          135deg,
          #0f172a 0%,
          #1e293b 50%,
          #0f172a 100%
        );
        font-family: Inter, system-ui, Segoe UI, Roboto, Arial;
        color: #e6eef8;
        overflow: hidden;
        position: relative;
      }

      /* Particles background */
      .particles {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        pointer-events: none;
      }

      .particle {
        position: absolute;
        width: 2px;
        height: 2px;
        background: #64748b;
        border-radius: 50%;
        opacity: 0.7;
        animation: float linear infinite;
      }

      @keyframes float {
        0% {
          transform: translateY(100vh) rotate(0deg);
          opacity: 0;
        }
        10% {
          opacity: 1;
        }
        90% {
          opacity: 1;
        }
        100% {
          transform: translateY(-100px) rotate(360deg);
          opacity: 0;
        }
      }

      .stage {
        width: calc(var(--size) + var(--gap));
        text-align: center;
      }

      .card {
        width: var(--size);
        height: var(--size);
        margin: 0 auto;
        perspective: 1000px;
        position: relative;
      }

      /* front/back faces */
      .face {
        width: 100%;
        height: 100%;
        border-radius: 12px;
        overflow: hidden;
        position: absolute;
        top: 0;
        left: 0;
        backface-visibility: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.6s cubic-bezier(0.2, 0.9, 0.3, 1),
          box-shadow 0.2s;
        box-shadow: 0 10px 30px rgba(2, 6, 23, 0.6);
      }

      img#trollImg {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
        pointer-events: auto;
        user-select: none;
        transform-origin: center;
        transition: transform 0.18s ease;
      }

      /* back face when flipped */
      .back {
        background: linear-gradient(135deg, #111827, #0b1220);
        transform: rotateY(180deg);
        color: #ffd166;
        font-weight: 700;
        font-size: 28px;
        letter-spacing: 2px;
      }

      /* flipped state */
      .flipped .face.front {
        transform: rotateY(180deg);
      }

      .flipped .face.back {
        transform: rotateY(360deg);
      }

      /* hover glitch + shake + glow */
      .card:hover img#trollImg {
        animation: tiny-wiggle 0.25s infinite;
        filter: contrast(1.05) saturate(1.05) brightness(1.1);
        transform: scale(1.02);
      }

      .card:hover .face.front {
        box-shadow: 0 10px 30px rgba(2, 6, 23, 0.6),
          0 0 20px rgba(255, 209, 102, 0.3), 0 0 40px rgba(255, 209, 102, 0.2),
          0 0 60px rgba(255, 209, 102, 0.1);
        animation: glow-pulse 2s ease-in-out infinite alternate;
      }

      @keyframes glow-pulse {
        0% {
          box-shadow: 0 10px 30px rgba(2, 6, 23, 0.6),
            0 0 20px rgba(255, 209, 102, 0.3), 0 0 40px rgba(255, 209, 102, 0.2),
            0 0 60px rgba(255, 209, 102, 0.1);
        }
        100% {
          box-shadow: 0 10px 30px rgba(2, 6, 23, 0.6),
            0 0 30px rgba(255, 209, 102, 0.4), 0 0 60px rgba(255, 209, 102, 0.3),
            0 0 90px rgba(255, 209, 102, 0.2);
        }
      }

      @keyframes tiny-wiggle {
        0% {
          transform: translateX(0);
        }

        25% {
          transform: translateX(-4px);
        }

        50% {
          transform: translateX(3px);
        }

        75% {
          transform: translateX(-2px);
        }

        100% {
          transform: translateX(0);
        }
      }

      /* quick "glitch" overlay effect using pseudo elements */
      .face.front::before,
      .face.front::after {
        content: "";
        position: absolute;
        inset: 0;
        pointer-events: none;
        mix-blend-mode: screen;
        background: transparent;
        opacity: 0;
      }

      .card.glitch .face.front::before {
        opacity: 0.7;
        animation: glitch-clip 350ms steps(10) infinite;
        background: linear-gradient(
          90deg,
          rgba(255, 0, 85, 0.18),
          rgba(0, 255, 200, 0.08)
        );
        mix-blend-mode: screen;
      }

      .card.glitch .face.front::after {
        opacity: 0.6;
        animation: glitch-shift 420ms linear infinite;
        background: linear-gradient(90deg, rgba(0, 0, 0, 0.12), transparent);
      }

      @keyframes glitch-clip {
        0% {
          clip-path: inset(10% 0 70% 0);
        }

        25% {
          clip-path: inset(40% 0 30% 0);
        }

        50% {
          clip-path: inset(5% 0 60% 0);
        }

        75% {
          clip-path: inset(60% 0 10% 0);
        }

        100% {
          clip-path: inset(10% 0 70% 0);
        }
      }

      @keyframes glitch-shift {
        0% {
          transform: translateX(0);
        }

        50% {
          transform: translateX(-6px);
        }

        100% {
          transform: translateX(0);
        }
      }

      /* playful caption with pulse effect */
      .hint {
        font-size: 13px;
        opacity: 0.8;
        margin-top: 12px;
        color: #94a3b8;
        animation: hint-pulse 2s ease-in-out infinite;
      }

      .hint h2 {
        margin: 0;
        background: linear-gradient(45deg, #94a3b8, #ffd166, #94a3b8);
        background-size: 200% 100%;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        animation: rainbow-text 3s ease-in-out infinite;
      }

      @keyframes hint-pulse {
        0%,
        100% {
          transform: scale(1);
          opacity: 0.8;
        }
        50% {
          transform: scale(1.05);
          opacity: 1;
        }
      }

      @keyframes rainbow-text {
        0%,
        100% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
      }

      /* Loading Animation */
      .loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          135deg,
          #0f172a 0%,
          #1e293b 50%,
          #0f172a 100%
        );
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        transition: opacity 0.5s ease-out;
      }

      .loading-overlay.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .loader {
        position: relative;
        width: 80px;
        height: 80px;
      }

      .loader::before,
      .loader::after {
        content: "";
        position: absolute;
        border: 4px solid transparent;
        border-top: 4px solid #ffd166;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      .loader::before {
        width: 80px;
        height: 80px;
        top: 0;
        left: 0;
      }

      .loader::after {
        width: 60px;
        height: 60px;
        top: 10px;
        left: 10px;
        border-top-color: #94a3b8;
        animation-direction: reverse;
        animation-duration: 0.8s;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .loading-text {
        color: #e6eef8;
        font-size: 18px;
        margin-top: 20px;
        opacity: 0.8;
        animation: fade 1.5s ease-in-out infinite alternate;
      }

      @keyframes fade {
        0% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      /* responsive */
      @media (max-width: 420px) {
        :root {
          --size: 260px;
        }
      }
    </style>
  </head>
  <body>
    <div class="loading-overlay" id="loadingOverlay">
      <div style="text-align: center">
        <div class="loader"></div>
        <div class="loading-text">Đang tải trang...</div>
      </div>
    </div>

    <div class="particles" id="particles"></div>
    <div class="stage">
      <div class="card" id="card">
        <div class="face front" id="frontFace">
          <img
            id="trollImg"
            src="img/bc573121-838b-4a1d-9bbf-79ca5f2570bc.jfif"
            alt="Trollable image"
          />
        </div>
        <div class="face back" id="backFace">Em ăn cứccc!</div>
      </div>

      <div class="hint"><h2>bấm vô ảnh đi na heo </h2></div>
    </div>

    <script>
      // Tạo particles background
      function createParticles() {
        const particlesContainer = document.getElementById("particles");
        const particleCount = 50;

        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement("div");
          particle.className = "particle";

          // Random position và size
          particle.style.left = Math.random() * 100 + "%";
          particle.style.width = particle.style.height =
            Math.random() * 3 + 1 + "px";
          particle.style.animationDuration = Math.random() * 3 + 2 + "s";
          particle.style.animationDelay = Math.random() * 2 + "s";

          // Random opacity và color
          const colors = ["#64748b", "#94a3b8", "#cbd5e1", "#e2e8f0"];
          particle.style.background =
            colors[Math.floor(Math.random() * colors.length)];
          particle.style.opacity = Math.random() * 0.5 + 0.3;

          particlesContainer.appendChild(particle);
        }
      }

      // Gọi tạo particles khi trang load
      createParticles();

      // Sound effects
      function createAudioContext() {
        const audioContext = new (window.AudioContext ||
          window.webkitAudioContext)();

        function playBeep(frequency, duration, type = "sine") {
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();

          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);

          oscillator.frequency.setValueAtTime(
            frequency,
            audioContext.currentTime
          );
          oscillator.type = type;

          gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(
            0.01,
            audioContext.currentTime + duration
          );

          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + duration);
        }

        return { playBeep };
      }

      let audioManager = null;

      // Khởi tạo audio context sau user interaction đầu tiên
      function initAudio() {
        if (!audioManager) {
          audioManager = createAudioContext();
        }
      }

      // Loading animation
      window.addEventListener("load", function () {
        setTimeout(function () {
          const loadingOverlay = document.getElementById("loadingOverlay");
          loadingOverlay.classList.add("hidden");
          setTimeout(function () {
            loadingOverlay.style.display = "none";
          }, 500);
        }, 1500); // Hiển thị loading trong 1.5 giây
      });

      (function () {
        const card = document.getElementById("card");
        const img = document.getElementById("trollImg");
        const stage = card.parentElement;
        let flipped = false;

        // bật/tắt hiệu ứng glitch ngắn khi hover
        let glitchTimer;
        img.addEventListener("mouseenter", () => {
          initAudio();
          if (audioManager) {
            audioManager.playBeep(800, 0.1, "square"); // Âm thanh khi hover
          }
          card.classList.add("glitch");
          clearTimeout(glitchTimer);
          glitchTimer = setTimeout(() => card.classList.remove("glitch"), 900);
        });

        // click để lật mặt
        card.addEventListener("click", (e) => {
          initAudio();
          if (audioManager) {
            if (!flipped) {
              audioManager.playBeep(1200, 0.2, "sawtooth"); // Âm thanh khi click lật
            } else {
              audioManager.playBeep(600, 0.2, "triangle"); // Âm thanh khi click lật lại
            }
          }
          flipped = !flipped;
          card.classList.toggle("flipped", flipped);
          // nếu lật thì bỏ glitch/run
          if (flipped) {
            card.classList.remove("glitch");
            img.style.transform = "";
          }
        });

        // "chạy trốn" khi con trỏ tới gần
        stage.addEventListener("mousemove", (e) => {
          if (flipped) return; // nếu đã bị lật thì dừng
          const rect = card.getBoundingClientRect();
          const cx = rect.left + rect.width / 2;
          const cy = rect.top + rect.height / 2;
          const distX = e.clientX - cx;
          const distY = e.clientY - cy;
          const distance = Math.hypot(distX, distY);

          // nếu con trỏ gần hơn threshold => dịch chuyển ảnh đi chỗ khác
          const threshold = Math.min(rect.width, 220);
          if (distance < threshold) {
            // tỉ lệ dịch chuyển theo khoảng cách (xa hơn => ít dịch)
            const strength = Math.max(
              12,
              Math.round((threshold - distance) / 3)
            );
            // hướng dịch chuyển theo ngược lại con trỏ (trốn)
            const moveX = -(distX / (rect.width / 2)) * strength;
            const moveY = -(distY / (rect.height / 2)) * strength;

            // giới hạn dịch chuyển để ảnh không bay ra ngoài stage
            img.style.transform = `translate(${clamp(
              moveX,
              -rect.width * 0.28,
              rect.width * 0.28
            )}px, ${clamp(
              moveY,
              -rect.height * 0.28,
              rect.height * 0.28
            )}px) scale(1.03)`;
            // cũng kích hoạt glitch ngắn
            card.classList.add("glitch");
            clearTimeout(glitchTimer);
            glitchTimer = setTimeout(
              () => card.classList.remove("glitch"),
              500
            );
          } else {
            // trở về vị trí ban đầu
            img.style.transform = "";
          }
        });

        // nếu chuột rời stage -> reset
        stage.addEventListener("mouseleave", () => {
          img.style.transform = "";
        });

        function clamp(v, a, b) {
          return Math.max(a, Math.min(b, v));
        }
      })();
    </script>
  </body>
</html>
